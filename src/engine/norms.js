/**
 * Norm models
 *
 * The app is self-contained: it ships with a conservative baseline model.
 * You can optionally load a custom norm pack (JSON) generated by the included pipeline.
 *
 * Supported norm pack fields:
 *  - name, version, createdAt, notes
 *  - thetaToIQ: { mean, sd, thetaMean, thetaSd }
 *  - ageBands: [{ id, label, thetaMean, thetaSd, n }]
 *  - indices: { <subtestId>: { mean, sd, weight, label } }
 *  - fairness (optional): { flaggedItems: [...], difMh: [...], difLogistic: [...], note }
 */

const BASELINE_CREATED = '2025-12-15';

export function loadBaselineNorms(){
  return {
    name: 'Baseline (generic, self-contained)',
    version: '0.4',
    createdAt: BASELINE_CREATED,
    notes: 'Generic mapping theta to IQ with mean 100 sd 15. Use a custom norm pack for improved calibration.',

    thetaToIQ: { mean: 100, sd: 15, thetaMean: 0, thetaSd: 1 },

    ageBands: [
      { id: '16-17', label: '16-17', thetaMean: 0, thetaSd: 1, n: 0 },
      { id: '18-24', label: '18-24', thetaMean: 0, thetaSd: 1, n: 0 },
      { id: '25-34', label: '25-34', thetaMean: 0, thetaSd: 1, n: 0 },
      { id: '35-44', label: '35-44', thetaMean: 0, thetaSd: 1, n: 0 },
      { id: '45-54', label: '45-54', thetaMean: 0, thetaSd: 1, n: 0 },
      { id: '55-64', label: '55-64', thetaMean: 0, thetaSd: 1, n: 0 },
      { id: '65+', label: '65+', thetaMean: 0, thetaSd: 1, n: 0 }
    ],

    indices: {
      fluid: { mean: 0, sd: 1, weight: 1.25, label: 'Fluid Reasoning Index' },
      verbal:{ mean: 0, sd: 1, weight: 1.05, label: 'Verbal Reasoning Index' },
      quant: { mean: 0, sd: 1, weight: 1.05, label: 'Quantitative Reasoning Index' },
      wm:    { mean: 0, sd: 1, weight: 0.95, label: 'Working Memory Index' },
      speed_symbol:{ mean: 0, sd: 1, weight: 0.85, label: 'Processing Speed (Symbol) Index' },
      speed_coding:{ mean: 0, sd: 1, weight: 0.85, label: 'Processing Speed (Coding) Index' },
      spatial:{ mean: 0, sd: 1, weight: 1.00, label: 'Spatial Reasoning Index' }
    },

    fairness: { note: 'Baseline pack only; DIF/fairness not computed.', flaggedItems: [], difMh: [], difLogistic: [] }
  };
}

export function validateNormPack(pack){
  const errors = [];
  const warnings = [];

  if (!pack || typeof pack !== 'object'){
    errors.push('Norm pack must be a JSON object.');
    return { valid: false, errors, warnings };
  }

  if (!pack.thetaToIQ || typeof pack.thetaToIQ !== 'object'){
    errors.push('Missing thetaToIQ mapping.');
  } else {
    const t = pack.thetaToIQ;
    if (!isFinite(t.thetaMean) || !isFinite(t.thetaSd) || t.thetaSd <= 0){
      errors.push('thetaToIQ.thetaMean/thetaSd must be finite and thetaSd > 0.');
    }
    if (!isFinite(t.mean) || !isFinite(t.sd) || t.sd <= 0){
      warnings.push('thetaToIQ mean/sd missing; default 100/15 will be assumed.');
    }
  }

  if (pack.ageBands != null){
    if (!Array.isArray(pack.ageBands)){
      errors.push('ageBands must be an array when provided.');
    } else {
      pack.ageBands.forEach((b, i) => {
        if (!isFinite(b.thetaMean) || !isFinite(b.thetaSd) || b.thetaSd <= 0){
          warnings.push(`ageBands[${i}] has invalid thetaMean/thetaSd; it will be ignored.`);
        }
      });
    }
  }

  if (pack.indices != null && typeof pack.indices === 'object'){
    Object.entries(pack.indices).forEach(([k,v]) => {
      if (!v || typeof v !== 'object'){
        warnings.push(`indices.${k} is not an object; ignoring.`);
      }
    });
  }

  if (pack.fairness != null && typeof pack.fairness === 'object'){
    ['flaggedItems','difMh','difLogistic'].forEach(key => {
      const arr = pack.fairness[key];
      if (arr != null && !Array.isArray(arr)){
        warnings.push(`fairness.${key} should be an array.`);
      }
    });
  }

  if (!pack.version){
    warnings.push('Missing version field; consider adding one.');
  }
  if (!pack.name){
    warnings.push('Missing name field; consider adding one.');
  }

  return { valid: errors.length === 0, errors, warnings };
}

export function loadCustomNorms(key){
  try{
    const raw = localStorage.getItem(key);
    if (!raw) return null;
    const obj = JSON.parse(raw);
    const v = validateNormPack(obj);
    if (!v.valid) return null;
    return obj;
  }catch{
    return null;
  }
}

export function clearCustomNorms(key){
  localStorage.removeItem(key);
}

function summarizeFairness(fairness){
  if (!fairness || typeof fairness !== 'object') return null;
  const flagged = Array.isArray(fairness.flaggedItems) ? fairness.flaggedItems.length : 0;
  const difMh = Array.isArray(fairness.difMh) ? fairness.difMh.length : 0;
  const difLogistic = Array.isArray(fairness.difLogistic) ? fairness.difLogistic.length : 0;
  return { flagged, difMh, difLogistic, note: fairness.note || null };
}

export function getNormsMeta(norms){
  return {
    name: norms?.name || 'Unknown',
    version: norms?.version || 'Unknown',
    createdAt: norms?.createdAt || null,
    fairness: summarizeFairness(norms?.fairness)
  };
}
